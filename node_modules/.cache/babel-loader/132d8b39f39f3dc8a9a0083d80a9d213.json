{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: !0\n});\n\nvar VALIDATOR_ARG_ERROR_MESSAGE = 'The typeValidator argument must be a function with the signature function(props, propName, componentName).',\n    MESSAGE_ARG_ERROR_MESSAGE = 'The error message is optional, but must be a string if provided.',\n    propIsRequired = function propIsRequired(a, b, c, d) {\n  if ('boolean' == typeof a) return a;\n  return 'function' == typeof a ? a(b, c, d) : !(!0 !== !!a) && !!a;\n},\n    propExists = function propExists(a, b) {\n  return Object.hasOwnProperty.call(a, b);\n},\n    missingPropError = function missingPropError(a, b, c, d) {\n  return d ? new Error(d) : new Error('Required ' + a[b] + ' `' + b + '`' + (' was not specified in `' + c + '`.'));\n},\n    guardAgainstInvalidArgTypes = function guardAgainstInvalidArgTypes(a, b) {\n  if ('function' != typeof a) throw new TypeError(VALIDATOR_ARG_ERROR_MESSAGE);\n  if (!!b && 'string' != typeof b) throw new TypeError(MESSAGE_ARG_ERROR_MESSAGE);\n},\n    isRequiredIf = function isRequiredIf(a, b, c) {\n  return guardAgainstInvalidArgTypes(a, c), function (d, e, f) {\n    for (var _len = arguments.length, g = Array(3 < _len ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      g[_key - 3] = arguments[_key];\n    }\n\n    return propIsRequired(b, d, e, f) ? propExists(d, e) ? a.apply(void 0, [d, e, f].concat(g)) : missingPropError(d, e, f, c) : a.apply(void 0, [d, e, f].concat(g)); // Is not required, so just run typeValidator.\n  };\n};\n\nexports.default = isRequiredIf;","map":{"version":3,"mappings":";;;;;;AAAA,IAAMA,0IAAN;AAAA,IAIMC,4BACJ,kEALF;AAAA,IAOMC,iBAAiB,SAAjBA,cAAiB,CAACC,CAAD,EAAYC,CAAZ,EAAmBC,CAAnB,EAA6BC,CAA7B,EAA+C;EACpE,IAAyB,aAArB,OAAOH,CAAX,EACE,OAAOA,CAAP;EAFkE,OAGpC,cAArB,OAAOA,CAAc,GACvBA,EAAUC,CAAV,EAAiBC,CAAjB,EAA2BC,CAA3B,CADuB,GAHoC,EAKzD,SAAQH,CALiD,OAMnDA,CANmD;AAPtE;AAAA,IAmBMI,aAAa,SAAbA,UAAa,CAACJ,CAAD,EAAQC,CAAR;EAAA,OAAqBI,OAAOC,cAAP,CAAsBC,IAAtB,CAA2BP,CAA3B,EAAkCC,CAAlC,CAArB;AAnBnB;AAAA,IAqBMO,mBAAmB,SAAnBA,gBAAmB,CAACR,CAAD,EAAQC,CAAR,EAAkBC,CAAlB,EAAiCC,CAAjC,EAA6C;EAAA,OAChEA,CADgE,GAE3D,IAAIM,KAAJ,CAAUN,CAAV,CAF2D,GAK7D,IAAIM,KAAJ,CACL,cAAYT,EAAMC,CAAN,CAAZ,UAAiCA,CAAjC,sCAC2BC,CAD3B,QADK,CAL6D;AArBtE;AAAA,IAgCMQ,8BAA8B,SAA9BA,2BAA8B,CAACV,CAAD,EAAgBC,CAAhB,EAA4B;EAC9D,IAA6B,cAAzB,OAAOD,CAAX,EACE,MAAM,IAAIW,SAAJ,CAAcd,2BAAd,CAAN;EAGF,IAAI,EAAQI,CAAR,IAAuC,YAAnB,OAAOA,CAA/B,EACE,MAAM,IAAIU,SAAJ,CAAcb,yBAAd,CAAN;AAtCJ;AAAA,IA0CMc,eAAe,SAAfA,YAAe,CAACZ,CAAD,EAAgBC,CAAhB,EAA2BC,CAA3B,EAAuC;EAG1D,OAFAQ,4BAA4BV,CAA5B,EAA2CE,CAA3C,GAEO,UAACC,CAAD,EAAQU,CAAR,EAAkBC,CAAlB,EAA6C;IAAA,kCAATC,CAAS;MAATA,CAAS,UAAT,GAASC,eAAT;IAAS;;IAAA,OAC9CjB,eAAeE,CAAf,EAA0BE,CAA1B,EAAiCU,CAAjC,EAA2CC,CAA3C,IACEV,WAAWD,CAAX,EAAkBU,CAAlB,IACKb,iBAAcG,CAAd,EAAqBU,CAArB,EAA+BC,CAA/B,SAAiDC,CAAjD,EADL,GAIGP,iBAAiBL,CAAjB,EAAwBU,CAAxB,EAAkCC,CAAlC,EAAiDZ,CAAjD,CALL,GASGF,iBAAcG,CAAd,EAAqBU,CAArB,EAA+BC,CAA/B,SAAiDC,CAAjD,EAV2C,EASlD;EAGH,CAZC;AA7CF;;kBA2DeH,Y","names":["VALIDATOR_ARG_ERROR_MESSAGE","MESSAGE_ARG_ERROR_MESSAGE","propIsRequired","a","b","c","d","propExists","Object","hasOwnProperty","call","missingPropError","Error","guardAgainstInvalidArgTypes","TypeError","isRequiredIf","e","f","g","arguments"],"sources":["../isRequiredIf.js"],"sourcesContent":["const VALIDATOR_ARG_ERROR_MESSAGE =\n  'The typeValidator argument must be a function ' +\n  'with the signature function(props, propName, componentName).';\n\nconst MESSAGE_ARG_ERROR_MESSAGE =\n  'The error message is optional, but must be a string if provided.';\n\nconst propIsRequired = (condition, props, propName, componentName) => {\n  if (typeof condition === 'boolean') {\n    return condition;\n  } else if (typeof condition === 'function') {\n    return condition(props, propName, componentName);\n  } else if (Boolean(condition) === true) {\n    return Boolean(condition);\n  }\n\n  return false;\n};\n\nconst propExists = (props, propName) => Object.hasOwnProperty.call(props, propName);\n\nconst missingPropError = (props, propName, componentName, message) => {\n  if (message) {\n    return new Error(message);\n  }\n\n  return new Error(\n    `Required ${props[propName]} \\`${propName}\\`` +\n    ` was not specified in \\`${componentName}\\`.`,\n  );\n};\n\nconst guardAgainstInvalidArgTypes = (typeValidator, message) => {\n  if (typeof typeValidator !== 'function') {\n    throw new TypeError(VALIDATOR_ARG_ERROR_MESSAGE);\n  }\n\n  if (Boolean(message) && typeof message !== 'string') {\n    throw new TypeError(MESSAGE_ARG_ERROR_MESSAGE);\n  }\n};\n\nconst isRequiredIf = (typeValidator, condition, message) => {\n  guardAgainstInvalidArgTypes(typeValidator, message);\n\n  return (props, propName, componentName, ...rest) => {\n    if (propIsRequired(condition, props, propName, componentName)) {\n      if (propExists(props, propName)) {\n        return typeValidator(props, propName, componentName, ...rest);\n      }\n\n      return missingPropError(props, propName, componentName, message);\n    }\n\n    // Is not required, so just run typeValidator.\n    return typeValidator(props, propName, componentName, ...rest);\n  };\n};\n\nexport default isRequiredIf;\n"]},"metadata":{},"sourceType":"script"}